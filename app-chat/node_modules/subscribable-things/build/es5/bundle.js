(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs-interop'), require('@babel/runtime/helpers/defineProperty')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs-interop', '@babel/runtime/helpers/defineProperty'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.subscribableThings = {}, global.rxjsInterop, global._defineProperty));
}(this, (function (exports, rxjsInterop, _defineProperty) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

    var createAnimationFrame = function createAnimationFrame(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.cancelAnimationFrame === undefined || window.requestAnimationFrame === undefined) {
            return emitNotSupportedError(observer);
          }

          var animationFrameHandle = window.requestAnimationFrame(function animationFrameCallback(timestamp) {
            animationFrameHandle = window.requestAnimationFrame(animationFrameCallback);
            observer.next(timestamp);
          });
          return function () {
            return window.cancelAnimationFrame(animationFrameHandle);
          };
        });
      };
    };

    var createIntersections = function createIntersections(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.IntersectionObserver === undefined) {
            return emitNotSupportedError(observer);
          }

          var intersectionObserverObserver = new window.IntersectionObserver(function (entries) {
            return observer.next(entries);
          }, options);

          try {
            intersectionObserverObserver.observe(htmlElement);
          } catch (err) {
            observer.error(err);
          }

          return function () {
            return intersectionObserverObserver.disconnect();
          };
        });
      };
    };

    var createMediaDevices = function createMediaDevices(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.mediaDevices === undefined || window.navigator.mediaDevices.enumerateDevices === undefined) {
            return emitNotSupportedError(observer);
          }

          var isActive = true;

          var enumerateDevices = function enumerateDevices() {
            window.navigator.mediaDevices.enumerateDevices().then(function (mediaDevices) {
              if (isActive) {
                observer.next(mediaDevices);
              }
            }, function (err) {
              if (isActive) {
                unsubscribe();
                observer.error(err);
              }
            });
          };

          var unsubscribe = function unsubscribe() {
            isActive = false;
            window.navigator.mediaDevices.removeEventListener('devicechange', enumerateDevices);
          };

          enumerateDevices();
          window.navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
          return unsubscribe;
        });
      };
    };

    var createMediaQueryMatch = function createMediaQueryMatch(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (mediaQueryString) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.matchMedia === undefined) {
            return emitNotSupportedError(observer);
          }

          var mediaQueryList = window.matchMedia(mediaQueryString);
          observer.next(mediaQueryList.matches);

          mediaQueryList.onchange = function () {
            return observer.next(mediaQueryList.matches);
          };

          return function () {
            mediaQueryList.onchange = null;
          };
        });
      };
    };

    var createMetrics = function createMetrics(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.PerformanceObserver === undefined) {
            return emitNotSupportedError(observer);
          }

          var performanceObserver = new window.PerformanceObserver(function (entryList) {
            return observer.next(entryList.getEntries());
          });

          try {
            performanceObserver.observe(options);
          } catch (err) {
            observer.error(err);
          }

          return function () {
            return performanceObserver.disconnect();
          };
        });
      };
    };

    var createMidiInputs = function createMidiInputs(wrapSubscribeFunction) {
      return function (midiAccess) {
        return wrapSubscribeFunction(function (observer) {
          var midiInputs = Array.from(midiAccess.inputs.values());

          var emitMidiInputs = function emitMidiInputs() {
            var midiAccessInputs = midiAccess.inputs;

            if (midiInputs.length !== midiAccessInputs.size || midiInputs.some(function (_ref) {
              var id = _ref.id;
              return !midiAccessInputs.has(id);
            })) {
              midiInputs = Array.from(midiAccessInputs.values());
              observer.next(midiInputs);
            }
          };

          observer.next(midiInputs);
          midiAccess.addEventListener('statechange', emitMidiInputs);
          return function () {
            return midiAccess.removeEventListener('statechange', emitMidiInputs);
          };
        });
      };
    };

    var createMidiOutputs = function createMidiOutputs(wrapSubscribeFunction) {
      return function (midiAccess) {
        return wrapSubscribeFunction(function (observer) {
          var midiOutputs = Array.from(midiAccess.outputs.values());

          var emitMidiOutputs = function emitMidiOutputs() {
            var midiAccessOutputs = midiAccess.outputs;

            if (midiOutputs.length !== midiAccessOutputs.size || midiOutputs.some(function (_ref) {
              var id = _ref.id;
              return !midiAccessOutputs.has(id);
            })) {
              midiOutputs = Array.from(midiAccessOutputs.values());
              observer.next(midiOutputs);
            }
          };

          observer.next(midiOutputs);
          midiAccess.addEventListener('statechange', emitMidiOutputs);
          return function () {
            return midiAccess.removeEventListener('statechange', emitMidiOutputs);
          };
        });
      };
    };

    var createMutations = function createMutations(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.MutationObserver === undefined) {
            return emitNotSupportedError(observer);
          }

          var mutationObserver = new window.MutationObserver(function (records) {
            return observer.next(records);
          });

          try {
            mutationObserver.observe(htmlElement, options);
          } catch (err) {
            observer.error(err);
          }

          return function () {
            return mutationObserver.disconnect();
          };
        });
      };
    };

    var createOn = function createOn(wrapSubscribeFunction) {
      return function (target, type, options) {
        return wrapSubscribeFunction(function (observer) {
          var listener = function listener(event) {
            return observer.next(event);
          };

          target.addEventListener(type, listener, options);
          return function () {
            return target.removeEventListener(type, listener, options);
          };
        });
      };
    };

    var createOnline = function createOnline(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.onLine === undefined) {
            return emitNotSupportedError(observer);
          }

          var emitFalse = function emitFalse() {
            return observer.next(false);
          };

          var emitTrue = function emitTrue() {
            return observer.next(true);
          };

          window.addEventListener('offline', emitFalse);
          window.addEventListener('online', emitTrue);
          observer.next(window.navigator.onLine);
          return function () {
            window.removeEventListener('offline', emitFalse);
            window.removeEventListener('online', emitTrue);
          };
        });
      };
    };

    var createPermissionState = function createPermissionState(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (permissionDescriptor) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.permissions === undefined || window.navigator.permissions.query === undefined) {
            return emitNotSupportedError(observer);
          }

          var isActive = true;

          var unsubscribe = function unsubscribe() {
            isActive = false;
          };

          window.navigator.permissions.query(permissionDescriptor).then(function (permissionStatus) {
            if (isActive) {
              observer.next(permissionStatus.state);
            }

            if (isActive) {
              permissionStatus.onchange = function () {
                return observer.next(permissionStatus.state);
              };

              unsubscribe = function unsubscribe() {
                permissionStatus.onchange = null;
              };
            }
          }, function (err) {
            if (isActive) {
              observer.error(err);
            }
          });
          return function () {
            return unsubscribe();
          };
        });
      };
    };

    var createReports = function createReports(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.ReportingObserver === undefined) {
            return emitNotSupportedError(observer);
          }

          var reportingObserver = new window.ReportingObserver(function (reportList) {
            return observer.next(reportList);
          }, options);
          reportingObserver.observe();
          return function () {
            return reportingObserver.disconnect();
          };
        });
      };
    };

    var createResizes = function createResizes(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.ResizeObserver === undefined) {
            return emitNotSupportedError(observer);
          }

          var resizeObserver = new window.ResizeObserver(function (entries) {
            return observer.next(entries);
          });

          try {
            resizeObserver.observe(htmlElement, options);
          } catch (err) {
            observer.error(err);
          }

          return function () {
            return resizeObserver.disconnect();
          };
        });
      };
    };

    var createUnhandledRejection = function createUnhandledRejection(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (coolingOffPeriod) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.clearInterval === undefined || window.setInterval === undefined) {
            return emitNotSupportedError(observer);
          }

          var possiblyUnhandledRejections = new Map();
          var intervalId = null;

          var deletePossiblyUnhandledRejection = function deletePossiblyUnhandledRejection(_ref) {
            var promise = _ref.promise;
            return possiblyUnhandledRejections["delete"](promise);
          };

          var emitUnhandledRejection = function emitUnhandledRejection() {
            var latestTimestampToEmit = Date.now() - coolingOffPeriod;
            possiblyUnhandledRejections.forEach(function (_ref2, promise) {
              var reason = _ref2.reason,
                  timestamp = _ref2.timestamp;

              if (timestamp > latestTimestampToEmit) {
                return;
              }

              possiblyUnhandledRejections["delete"](promise);
              observer.next(reason);
            });

            if (intervalId !== null && possiblyUnhandledRejections.size === 0) {
              window.clearInterval(intervalId);
              intervalId = null;
            }
          };

          var registerPossiblyUnhandledRejection = function registerPossiblyUnhandledRejection(event) {
            event.preventDefault();
            possiblyUnhandledRejections.set(event.promise, {
              reason: event.reason,
              timestamp: Date.now()
            });

            if (intervalId === null) {
              intervalId = window.setInterval(emitUnhandledRejection, coolingOffPeriod / 2);
            }
          };

          window.addEventListener('rejectionhandled', deletePossiblyUnhandledRejection);
          window.addEventListener('unhandledrejection', registerPossiblyUnhandledRejection);
          return function () {
            if (intervalId !== null) {
              window.clearInterval(intervalId);
            }

            window.removeEventListener('rejectionhandled', deletePossiblyUnhandledRejection);
            window.removeEventListener('unhandledrejection', registerPossiblyUnhandledRejection);
          };
        });
      };
    };

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    var createVideoFrame = function createVideoFrame(emitNotSupportedError, wrapSubscribeFunction) {
      return function (videoElement) {
        return wrapSubscribeFunction(function (observer) {
          if (videoElement.cancelVideoFrameCallback === undefined || videoElement.requestVideoFrameCallback === undefined) {
            return emitNotSupportedError(observer);
          }

          var videoFrameHandle = videoElement.requestVideoFrameCallback(function videoFrameCallback(now, metadata) {
            videoFrameHandle = videoElement.requestVideoFrameCallback(videoFrameCallback);
            observer.next(_objectSpread(_objectSpread({}, metadata), {}, {
              now: now
            }));
          });
          return function () {
            return videoElement.cancelVideoFrameCallback(videoFrameHandle);
          };
        });
      };
    };

    var createWakeLock = function createWakeLock(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (type) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.wakeLock === undefined) {
            return emitNotSupportedError(observer);
          }

          var releaseWakeLock = function releaseWakeLock(wakeLockSentinel) {
            return wakeLockSentinel.release()["catch"](function () {// Ignore errors.
            });
          };

          var removeReleaseEventListener = function removeReleaseEventListener(wakeLockSentinel) {
            wakeLockSentinel.onrelease = null;
          };

          var isActive = true;

          var unsubscribeWhileRequesting = function unsubscribeWhileRequesting() {
            isActive = false;
          };

          var unsubscribe = unsubscribeWhileRequesting;

          var requestWakeLock = function requestWakeLock() {
            return window.navigator.wakeLock.request(type).then(function (wakeLockSentinel) {
              if (isActive) {
                observer.next(true);
              }

              if (isActive) {
                wakeLockSentinel.onrelease = function () {
                  observer.next(false);
                  unsubscribe = unsubscribeWhileRequesting;
                  removeReleaseEventListener(wakeLockSentinel);
                  requestWakeLock();
                };

                unsubscribe = function unsubscribe() {
                  removeReleaseEventListener(wakeLockSentinel);
                  releaseWakeLock(wakeLockSentinel);
                };
              } else {
                releaseWakeLock(wakeLockSentinel);
              }
            }, function (err) {
              if (isActive) {
                observer.error(err);
              }
            });
          };

          requestWakeLock();
          return function () {
            return unsubscribe();
          };
        });
      };
    };

    // @todo TypeScript does not include type definitions for the Reporting API yet.
    var createWindow = function createWindow() {
      return typeof window === 'undefined' ? null : window;
    };

    var createWrapSubscribeFunction = function createWrapSubscribeFunction(patch, toObserver) {
      var emptyFunction = function emptyFunction() {}; // tslint:disable-line:no-empty


      return function (innerSubscribe) {
        var _subscribe = function subscribe() {
          var unsubscribe = innerSubscribe(toObserver.apply(void 0, arguments));

          if (unsubscribe !== undefined) {
            return unsubscribe;
          }

          return emptyFunction;
        };

        _subscribe[Symbol.observable] = function () {
          return {
            subscribe: function subscribe() {
              return {
                unsubscribe: _subscribe.apply(void 0, arguments)
              };
            }
          };
        };

        return patch(_subscribe);
      };
    };

    var emitNotSupportedError = function emitNotSupportedError(observer) {
      observer.error(new Error('The required browser API seems to be not supported.'));
      return function () {}; // tslint:disable-line:no-empty
    };

    var window$1 = createWindow();
    var wrapSubscribeFunction = createWrapSubscribeFunction(rxjsInterop.patch, rxjsInterop.toObserver);
    var animationFrame = createAnimationFrame(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var intersections = createIntersections(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mediaDevices = createMediaDevices(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mediaQueryMatch = createMediaQueryMatch(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var metrics = createMetrics(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var midiInputs = createMidiInputs(wrapSubscribeFunction);
    var midiOutputs = createMidiOutputs(wrapSubscribeFunction);
    var mutations = createMutations(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var on = createOn(wrapSubscribeFunction);
    var online = createOnline(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var permissionState = createPermissionState(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var reports = createReports(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var resizes = createResizes(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var unhandledRejection = createUnhandledRejection(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var videoFrame = createVideoFrame(emitNotSupportedError, wrapSubscribeFunction);
    var wakeLock = createWakeLock(emitNotSupportedError, window$1, wrapSubscribeFunction);

    exports.animationFrame = animationFrame;
    exports.intersections = intersections;
    exports.mediaDevices = mediaDevices;
    exports.mediaQueryMatch = mediaQueryMatch;
    exports.metrics = metrics;
    exports.midiInputs = midiInputs;
    exports.midiOutputs = midiOutputs;
    exports.mutations = mutations;
    exports.on = on;
    exports.online = online;
    exports.permissionState = permissionState;
    exports.reports = reports;
    exports.resizes = resizes;
    exports.unhandledRejection = unhandledRejection;
    exports.videoFrame = videoFrame;
    exports.wakeLock = wakeLock;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
