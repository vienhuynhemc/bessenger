{"ast":null,"code":"'use strict';\n\nvar nodePreGyp = require('@mapbox/node-pre-gyp');\n\nvar path = require('path');\n\nvar binding_path = nodePreGyp.find(path.resolve(path.join(__dirname, './package.json')));\n\nvar bindings = require(binding_path);\n\nvar crypto = require('crypto');\n\nvar promises = require('./promises'); /// generate a salt (sync)\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @return {String} salt\n\n\nmodule.exports.genSaltSync = function genSaltSync(rounds, minor) {\n  // default 10 rounds\n  if (!rounds) {\n    rounds = 10;\n  } else if (typeof rounds !== 'number') {\n    throw new Error('rounds must be a number');\n  }\n\n  if (!minor) {\n    minor = 'b';\n  } else if (minor !== 'b' && minor !== 'a') {\n    throw new Error('minor must be either \"a\" or \"b\"');\n  }\n\n  return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));\n}; /// generate a salt\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @param {Function} cb callback(err, salt)\n\n\nmodule.exports.genSalt = function genSalt(rounds, minor, cb) {\n  var error; // if callback is first argument, then use defaults for others\n\n  if (typeof arguments[0] === 'function') {\n    // have to set callback first otherwise arguments are overriden\n    cb = arguments[0];\n    rounds = 10;\n    minor = 'b'; // callback is second argument\n  } else if (typeof arguments[1] === 'function') {\n    // have to set callback first otherwise arguments are overriden\n    cb = arguments[1];\n    minor = 'b';\n  }\n\n  if (!cb) {\n    return promises.promise(genSalt, this, [rounds, minor]);\n  } // default 10 rounds\n\n\n  if (!rounds) {\n    rounds = 10;\n  } else if (typeof rounds !== 'number') {\n    // callback error asynchronously\n    error = new Error('rounds must be a number');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (!minor) {\n    minor = 'b';\n  } else if (minor !== 'b' && minor !== 'a') {\n    error = new Error('minor must be either \"a\" or \"b\"');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  crypto.randomBytes(16, function (error, randomBytes) {\n    if (error) {\n      cb(error);\n      return;\n    }\n\n    bindings.gen_salt(minor, rounds, randomBytes, cb);\n  });\n}; /// hash data using a salt\n/// @param {String|Buffer} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @return {String} hash\n\n\nmodule.exports.hashSync = function hashSync(data, salt) {\n  if (data == null || salt == null) {\n    throw new Error('data and salt arguments required');\n  }\n\n  if (!(typeof data === 'string' || data instanceof Buffer) || typeof salt !== 'string' && typeof salt !== 'number') {\n    throw new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n  }\n\n  if (typeof salt === 'number') {\n    salt = module.exports.genSaltSync(salt);\n  }\n\n  return bindings.encrypt_sync(data, salt);\n}; /// hash data using a salt\n/// @param {String|Buffer} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @param {Function} cb callback(err, hash)\n\n\nmodule.exports.hash = function hash(data, salt, cb) {\n  var error;\n\n  if (typeof data === 'function') {\n    error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      data(error);\n    });\n  }\n\n  if (typeof salt === 'function') {\n    error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      salt(error);\n    });\n  } // cb exists but is not a function\n  // return a rejecting promise\n\n\n  if (cb && typeof cb !== 'function') {\n    return promises.reject(new Error('cb must be a function or null to return a Promise'));\n  }\n\n  if (!cb) {\n    return promises.promise(hash, this, [data, salt]);\n  }\n\n  if (data == null || salt == null) {\n    error = new Error('data and salt arguments required');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (!(typeof data === 'string' || data instanceof Buffer) || typeof salt !== 'string' && typeof salt !== 'number') {\n    error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (typeof salt === 'number') {\n    return module.exports.genSalt(salt, function (err, salt) {\n      return bindings.encrypt(data, salt, cb);\n    });\n  }\n\n  return bindings.encrypt(data, salt, cb);\n}; /// compare raw data to hash\n/// @param {String|Buffer} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @return {bool} true if hashed data matches hash\n\n\nmodule.exports.compareSync = function compareSync(data, hash) {\n  if (data == null || hash == null) {\n    throw new Error('data and hash arguments required');\n  }\n\n  if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {\n    throw new Error('data must be a string or Buffer and hash must be a string');\n  }\n\n  return bindings.compare_sync(data, hash);\n}; /// compare raw data to hash\n/// @param {String|Buffer} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash\n\n\nmodule.exports.compare = function compare(data, hash, cb) {\n  var error;\n\n  if (typeof data === 'function') {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      data(error);\n    });\n  }\n\n  if (typeof hash === 'function') {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      hash(error);\n    });\n  } // cb exists but is not a function\n  // return a rejecting promise\n\n\n  if (cb && typeof cb !== 'function') {\n    return promises.reject(new Error('cb must be a function or null to return a Promise'));\n  }\n\n  if (!cb) {\n    return promises.promise(compare, this, [data, hash]);\n  }\n\n  if (data == null || hash == null) {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {\n    error = new Error('data and hash must be strings');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  return bindings.compare(data, hash, cb);\n}; /// @param {String} hash extract rounds from this hash\n/// @return {Number} the number of rounds used to encrypt a given hash\n\n\nmodule.exports.getRounds = function getRounds(hash) {\n  if (hash == null) {\n    throw new Error('hash argument required');\n  }\n\n  if (typeof hash !== 'string') {\n    throw new Error('hash must be a string');\n  }\n\n  return bindings.get_rounds(hash);\n};","map":{"version":3,"sources":["E:/Important/FIT/project-front-end/FrontEnd_ThayLong_Nhom-21/app-chat/node_modules/bcrypt/bcrypt.js"],"names":["nodePreGyp","require","path","binding_path","find","resolve","join","__dirname","bindings","crypto","promises","module","exports","genSaltSync","rounds","minor","Error","gen_salt_sync","randomBytes","genSalt","cb","error","arguments","promise","process","nextTick","gen_salt","hashSync","data","salt","Buffer","encrypt_sync","hash","reject","err","encrypt","compareSync","compare_sync","compare","getRounds","get_rounds"],"mappings":"AAAA;;AAEA,IAAIA,UAAU,GAAGC,OAAO,CAAC,sBAAD,CAAxB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,YAAY,GAAGH,UAAU,CAACI,IAAX,CAAgBF,IAAI,CAACG,OAAL,CAAaH,IAAI,CAACI,IAAL,CAAUC,SAAV,EAAqB,gBAArB,CAAb,CAAhB,CAAnB;;AACA,IAAIC,QAAQ,GAAGP,OAAO,CAACE,YAAD,CAAtB;;AAEA,IAAIM,MAAM,GAAGR,OAAO,CAAC,QAAD,CAApB;;AAEA,IAAIS,QAAQ,GAAGT,OAAO,CAAC,YAAD,CAAtB,C,CAEA;AACA;AACA;;;AACAU,MAAM,CAACC,OAAP,CAAeC,WAAf,GAA6B,SAASA,WAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoC;AAC7D;AACA,MAAI,CAACD,MAAL,EAAa;AACTA,IAAAA,MAAM,GAAG,EAAT;AACH,GAFD,MAEO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AACnC,UAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,MAAG,CAACD,KAAJ,EAAW;AACPA,IAAAA,KAAK,GAAG,GAAR;AACH,GAFD,MAEO,IAAGA,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA9B,EAAmC;AACtC,UAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACH;;AAED,SAAOR,QAAQ,CAACS,aAAT,CAAuBF,KAAvB,EAA8BD,MAA9B,EAAsCL,MAAM,CAACS,WAAP,CAAmB,EAAnB,CAAtC,CAAP;AACH,CAfD,C,CAiBA;AACA;AACA;;;AACAP,MAAM,CAACC,OAAP,CAAeO,OAAf,GAAyB,SAASA,OAAT,CAAiBL,MAAjB,EAAyBC,KAAzB,EAAgCK,EAAhC,EAAoC;AACzD,MAAIC,KAAJ,CADyD,CAGzD;;AACA,MAAI,OAAOC,SAAS,CAAC,CAAD,CAAhB,KAAwB,UAA5B,EAAwC;AACpC;AACAF,IAAAA,EAAE,GAAGE,SAAS,CAAC,CAAD,CAAd;AACAR,IAAAA,MAAM,GAAG,EAAT;AACAC,IAAAA,KAAK,GAAG,GAAR,CAJoC,CAKxC;AACC,GAND,MAMO,IAAI,OAAOO,SAAS,CAAC,CAAD,CAAhB,KAAwB,UAA5B,EAAwC;AAC3C;AACAF,IAAAA,EAAE,GAAGE,SAAS,CAAC,CAAD,CAAd;AACAP,IAAAA,KAAK,GAAG,GAAR;AACH;;AAED,MAAI,CAACK,EAAL,EAAS;AACL,WAAOV,QAAQ,CAACa,OAAT,CAAiBJ,OAAjB,EAA0B,IAA1B,EAAgC,CAACL,MAAD,EAASC,KAAT,CAAhC,CAAP;AACH,GAlBwD,CAoBzD;;;AACA,MAAI,CAACD,MAAL,EAAa;AACTA,IAAAA,MAAM,GAAG,EAAT;AACH,GAFD,MAEO,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AACnC;AACAO,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,yBAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAED,MAAG,CAACN,KAAJ,EAAW;AACPA,IAAAA,KAAK,GAAG,GAAR;AACH,GAFD,MAEO,IAAGA,KAAK,KAAK,GAAV,IAAiBA,KAAK,KAAK,GAA9B,EAAmC;AACtCM,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,iCAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAEDZ,EAAAA,MAAM,CAACS,WAAP,CAAmB,EAAnB,EAAuB,UAASG,KAAT,EAAgBH,WAAhB,EAA6B;AAChD,QAAIG,KAAJ,EAAW;AACPD,MAAAA,EAAE,CAACC,KAAD,CAAF;AACA;AACH;;AAEDb,IAAAA,QAAQ,CAACkB,QAAT,CAAkBX,KAAlB,EAAyBD,MAAzB,EAAiCI,WAAjC,EAA8CE,EAA9C;AACH,GAPD;AAQH,CAhDD,C,CAkDA;AACA;AACA;AACA;;;AACAT,MAAM,CAACC,OAAP,CAAee,QAAf,GAA0B,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,IAAxB,EAA8B;AACpD,MAAID,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;AAC9B,UAAM,IAAIb,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,MAAI,EAAE,OAAOY,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,YAAYE,MAA9C,KAA0D,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAA1G,EAAqH;AACjH,UAAM,IAAIb,KAAJ,CAAU,6FAAV,CAAN;AACH;;AAED,MAAI,OAAOa,IAAP,KAAgB,QAApB,EAA8B;AAC1BA,IAAAA,IAAI,GAAGlB,MAAM,CAACC,OAAP,CAAeC,WAAf,CAA2BgB,IAA3B,CAAP;AACH;;AAED,SAAOrB,QAAQ,CAACuB,YAAT,CAAsBH,IAAtB,EAA4BC,IAA5B,CAAP;AACH,CAdD,C,CAgBA;AACA;AACA;AACA;;;AACAlB,MAAM,CAACC,OAAP,CAAeoB,IAAf,GAAsB,SAASA,IAAT,CAAcJ,IAAd,EAAoBC,IAApB,EAA0BT,EAA1B,EAA8B;AAChD,MAAIC,KAAJ;;AAEA,MAAI,OAAOO,IAAP,KAAgB,UAApB,EAAgC;AAC5BP,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,6FAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BG,MAAAA,IAAI,CAACP,KAAD,CAAJ;AACH,KAFM,CAAP;AAGH;;AAED,MAAI,OAAOQ,IAAP,KAAgB,UAApB,EAAgC;AAC5BR,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,6FAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BI,MAAAA,IAAI,CAACR,KAAD,CAAJ;AACH,KAFM,CAAP;AAGH,GAf+C,CAiBhD;AACA;;;AACA,MAAID,EAAE,IAAI,OAAOA,EAAP,KAAc,UAAxB,EAAoC;AAChC,WAAOV,QAAQ,CAACuB,MAAT,CAAgB,IAAIjB,KAAJ,CAAU,mDAAV,CAAhB,CAAP;AACH;;AAED,MAAI,CAACI,EAAL,EAAS;AACL,WAAOV,QAAQ,CAACa,OAAT,CAAiBS,IAAjB,EAAuB,IAAvB,EAA6B,CAACJ,IAAD,EAAOC,IAAP,CAA7B,CAAP;AACH;;AAED,MAAID,IAAI,IAAI,IAAR,IAAgBC,IAAI,IAAI,IAA5B,EAAkC;AAC9BR,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,kCAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAED,MAAI,EAAE,OAAOO,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,YAAYE,MAA9C,KAA0D,OAAOD,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAA1G,EAAqH;AACjHR,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,6FAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAGD,MAAI,OAAOQ,IAAP,KAAgB,QAApB,EAA8B;AAC1B,WAAOlB,MAAM,CAACC,OAAP,CAAeO,OAAf,CAAuBU,IAAvB,EAA6B,UAASK,GAAT,EAAcL,IAAd,EAAoB;AACpD,aAAOrB,QAAQ,CAAC2B,OAAT,CAAiBP,IAAjB,EAAuBC,IAAvB,EAA6BT,EAA7B,CAAP;AACH,KAFM,CAAP;AAGH;;AAED,SAAOZ,QAAQ,CAAC2B,OAAT,CAAiBP,IAAjB,EAAuBC,IAAvB,EAA6BT,EAA7B,CAAP;AACH,CAjDD,C,CAmDA;AACA;AACA;AACA;;;AACAT,MAAM,CAACC,OAAP,CAAewB,WAAf,GAA6B,SAASA,WAAT,CAAqBR,IAArB,EAA2BI,IAA3B,EAAiC;AAC1D,MAAIJ,IAAI,IAAI,IAAR,IAAgBI,IAAI,IAAI,IAA5B,EAAkC;AAC9B,UAAM,IAAIhB,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,MAAI,EAAE,OAAOY,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,YAAYE,MAA9C,KAAyD,OAAOE,IAAP,KAAgB,QAA7E,EAAuF;AACnF,UAAM,IAAIhB,KAAJ,CAAU,2DAAV,CAAN;AACH;;AAED,SAAOR,QAAQ,CAAC6B,YAAT,CAAsBT,IAAtB,EAA4BI,IAA5B,CAAP;AACH,CAVD,C,CAYA;AACA;AACA;AACA;;;AACArB,MAAM,CAACC,OAAP,CAAe0B,OAAf,GAAyB,SAASA,OAAT,CAAiBV,IAAjB,EAAuBI,IAAvB,EAA6BZ,EAA7B,EAAiC;AACtD,MAAIC,KAAJ;;AAEA,MAAI,OAAOO,IAAP,KAAgB,UAApB,EAAgC;AAC5BP,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,kCAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BG,MAAAA,IAAI,CAACP,KAAD,CAAJ;AACH,KAFM,CAAP;AAGH;;AAED,MAAI,OAAOW,IAAP,KAAgB,UAApB,EAAgC;AAC5BX,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,kCAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BO,MAAAA,IAAI,CAACX,KAAD,CAAJ;AACH,KAFM,CAAP;AAGH,GAfqD,CAiBtD;AACA;;;AACA,MAAID,EAAE,IAAI,OAAOA,EAAP,KAAc,UAAxB,EAAoC;AAChC,WAAOV,QAAQ,CAACuB,MAAT,CAAgB,IAAIjB,KAAJ,CAAU,mDAAV,CAAhB,CAAP;AACH;;AAED,MAAI,CAACI,EAAL,EAAS;AACL,WAAOV,QAAQ,CAACa,OAAT,CAAiBe,OAAjB,EAA0B,IAA1B,EAAgC,CAACV,IAAD,EAAOI,IAAP,CAAhC,CAAP;AACH;;AAED,MAAIJ,IAAI,IAAI,IAAR,IAAgBI,IAAI,IAAI,IAA5B,EAAkC;AAC9BX,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,kCAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAED,MAAI,EAAE,OAAOO,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,YAAYE,MAA9C,KAAyD,OAAOE,IAAP,KAAgB,QAA7E,EAAuF;AACnFX,IAAAA,KAAK,GAAG,IAAIL,KAAJ,CAAU,+BAAV,CAAR;AACA,WAAOQ,OAAO,CAACC,QAAR,CAAiB,YAAW;AAC/BL,MAAAA,EAAE,CAACC,KAAD,CAAF;AACH,KAFM,CAAP;AAGH;;AAED,SAAOb,QAAQ,CAAC8B,OAAT,CAAiBV,IAAjB,EAAuBI,IAAvB,EAA6BZ,EAA7B,CAAP;AACH,CA1CD,C,CA4CA;AACA;;;AACAT,MAAM,CAACC,OAAP,CAAe2B,SAAf,GAA2B,SAASA,SAAT,CAAmBP,IAAnB,EAAyB;AAChD,MAAIA,IAAI,IAAI,IAAZ,EAAkB;AACd,UAAM,IAAIhB,KAAJ,CAAU,wBAAV,CAAN;AACH;;AAED,MAAI,OAAOgB,IAAP,KAAgB,QAApB,EAA8B;AAC1B,UAAM,IAAIhB,KAAJ,CAAU,uBAAV,CAAN;AACH;;AAED,SAAOR,QAAQ,CAACgC,UAAT,CAAoBR,IAApB,CAAP;AACH,CAVD","sourcesContent":["'use strict';\n\nvar nodePreGyp = require('@mapbox/node-pre-gyp');\nvar path = require('path');\nvar binding_path = nodePreGyp.find(path.resolve(path.join(__dirname, './package.json')));\nvar bindings = require(binding_path);\n\nvar crypto = require('crypto');\n\nvar promises = require('./promises');\n\n/// generate a salt (sync)\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @return {String} salt\nmodule.exports.genSaltSync = function genSaltSync(rounds, minor) {\n    // default 10 rounds\n    if (!rounds) {\n        rounds = 10;\n    } else if (typeof rounds !== 'number') {\n        throw new Error('rounds must be a number');\n    }\n\n    if(!minor) {\n        minor = 'b';\n    } else if(minor !== 'b' && minor !== 'a') {\n        throw new Error('minor must be either \"a\" or \"b\"');\n    }\n\n    return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));\n};\n\n/// generate a salt\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @param {Function} cb callback(err, salt)\nmodule.exports.genSalt = function genSalt(rounds, minor, cb) {\n    var error;\n\n    // if callback is first argument, then use defaults for others\n    if (typeof arguments[0] === 'function') {\n        // have to set callback first otherwise arguments are overriden\n        cb = arguments[0];\n        rounds = 10;\n        minor = 'b';\n    // callback is second argument\n    } else if (typeof arguments[1] === 'function') {\n        // have to set callback first otherwise arguments are overriden\n        cb = arguments[1];\n        minor = 'b';\n    }\n\n    if (!cb) {\n        return promises.promise(genSalt, this, [rounds, minor]);\n    }\n\n    // default 10 rounds\n    if (!rounds) {\n        rounds = 10;\n    } else if (typeof rounds !== 'number') {\n        // callback error asynchronously\n        error = new Error('rounds must be a number');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n    if(!minor) {\n        minor = 'b'\n    } else if(minor !== 'b' && minor !== 'a') {\n        error = new Error('minor must be either \"a\" or \"b\"');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n    crypto.randomBytes(16, function(error, randomBytes) {\n        if (error) {\n            cb(error);\n            return;\n        }\n\n        bindings.gen_salt(minor, rounds, randomBytes, cb);\n    });\n};\n\n/// hash data using a salt\n/// @param {String|Buffer} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @return {String} hash\nmodule.exports.hashSync = function hashSync(data, salt) {\n    if (data == null || salt == null) {\n        throw new Error('data and salt arguments required');\n    }\n\n    if (!(typeof data === 'string' || data instanceof Buffer) || (typeof salt !== 'string' && typeof salt !== 'number')) {\n        throw new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n    }\n\n    if (typeof salt === 'number') {\n        salt = module.exports.genSaltSync(salt);\n    }\n\n    return bindings.encrypt_sync(data, salt);\n};\n\n/// hash data using a salt\n/// @param {String|Buffer} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @param {Function} cb callback(err, hash)\nmodule.exports.hash = function hash(data, salt, cb) {\n    var error;\n\n    if (typeof data === 'function') {\n        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n        return process.nextTick(function() {\n            data(error);\n        });\n    }\n\n    if (typeof salt === 'function') {\n        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n        return process.nextTick(function() {\n            salt(error);\n        });\n    }\n\n    // cb exists but is not a function\n    // return a rejecting promise\n    if (cb && typeof cb !== 'function') {\n        return promises.reject(new Error('cb must be a function or null to return a Promise'));\n    }\n\n    if (!cb) {\n        return promises.promise(hash, this, [data, salt]);\n    }\n\n    if (data == null || salt == null) {\n        error = new Error('data and salt arguments required');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n    if (!(typeof data === 'string' || data instanceof Buffer) || (typeof salt !== 'string' && typeof salt !== 'number')) {\n        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n\n    if (typeof salt === 'number') {\n        return module.exports.genSalt(salt, function(err, salt) {\n            return bindings.encrypt(data, salt, cb);\n        });\n    }\n\n    return bindings.encrypt(data, salt, cb);\n};\n\n/// compare raw data to hash\n/// @param {String|Buffer} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @return {bool} true if hashed data matches hash\nmodule.exports.compareSync = function compareSync(data, hash) {\n    if (data == null || hash == null) {\n        throw new Error('data and hash arguments required');\n    }\n\n    if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {\n        throw new Error('data must be a string or Buffer and hash must be a string');\n    }\n\n    return bindings.compare_sync(data, hash);\n};\n\n/// compare raw data to hash\n/// @param {String|Buffer} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash\nmodule.exports.compare = function compare(data, hash, cb) {\n    var error;\n\n    if (typeof data === 'function') {\n        error = new Error('data and hash arguments required');\n        return process.nextTick(function() {\n            data(error);\n        });\n    }\n\n    if (typeof hash === 'function') {\n        error = new Error('data and hash arguments required');\n        return process.nextTick(function() {\n            hash(error);\n        });\n    }\n\n    // cb exists but is not a function\n    // return a rejecting promise\n    if (cb && typeof cb !== 'function') {\n        return promises.reject(new Error('cb must be a function or null to return a Promise'));\n    }\n\n    if (!cb) {\n        return promises.promise(compare, this, [data, hash]);\n    }\n\n    if (data == null || hash == null) {\n        error = new Error('data and hash arguments required');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n    if (!(typeof data === 'string' || data instanceof Buffer) || typeof hash !== 'string') {\n        error = new Error('data and hash must be strings');\n        return process.nextTick(function() {\n            cb(error);\n        });\n    }\n\n    return bindings.compare(data, hash, cb);\n};\n\n/// @param {String} hash extract rounds from this hash\n/// @return {Number} the number of rounds used to encrypt a given hash\nmodule.exports.getRounds = function getRounds(hash) {\n    if (hash == null) {\n        throw new Error('hash argument required');\n    }\n\n    if (typeof hash !== 'string') {\n        throw new Error('hash must be a string');\n    }\n\n    return bindings.get_rounds(hash);\n};\n"]},"metadata":{},"sourceType":"script"}