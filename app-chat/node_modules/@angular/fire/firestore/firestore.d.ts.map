{"version":3,"file":"firestore.d.ts","sources":["firestore.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA","sourcesContent":["import { InjectionToken, NgZone } from '@angular/core';\r\nimport { Observable } from 'rxjs';\r\nimport { AssociatedReference, CollectionReference, DocumentReference, PersistenceSettings, QueryFn, QueryGroupFn, Settings } from './interfaces';\r\nimport { AngularFirestoreDocument } from './document/document';\r\nimport { AngularFirestoreCollection } from './collection/collection';\r\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\r\nimport { FirebaseAppConfig, FirebaseOptions, ɵAngularFireSchedulers } from '@angular/fire';\r\nimport firebase from 'firebase/app';\r\nimport 'firebase/firestore';\r\n/**\r\n * The value of this token determines whether or not the firestore will have persistance enabled\r\n */\r\nexport declare const ENABLE_PERSISTENCE: InjectionToken<boolean>;\r\nexport declare const PERSISTENCE_SETTINGS: InjectionToken<firebase.firestore.PersistenceSettings>;\r\nexport declare const SETTINGS: InjectionToken<firebase.firestore.Settings>;\r\ndeclare type UseEmulatorArguments = [string, number];\r\nexport declare const USE_EMULATOR: InjectionToken<UseEmulatorArguments>;\r\n/**\r\n * A utility methods for associating a collection reference with\r\n * a query.\r\n *\r\n * @param collectionRef - A collection reference to query\r\n * @param queryFn - The callback to create a query\r\n *\r\n * Example:\r\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\r\n *  return ref.where('age', '<', 200);\r\n * });\r\n */\r\nexport declare function associateQuery<T>(collectionRef: CollectionReference<T>, queryFn?: (ref: any) => any): AssociatedReference<T>;\r\n/**\r\n * AngularFirestore Service\r\n *\r\n * This service is the main entry point for this feature module. It provides\r\n * an API for creating Collection and Reference services. These services can\r\n * then be used to do data updates and observable streams of the data.\r\n *\r\n * Example:\r\n *\r\n * import { Component } from '@angular/core';\r\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\r\n * import { Observable } from 'rxjs/Observable';\r\n * import { from } from 'rxjs/observable';\r\n *\r\n * @Component({\r\n *   selector: 'app-my-component',\r\n *   template: `\r\n *    <h2>Items for {{ (profile | async)?.name }}\r\n *    <ul>\r\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\r\n *    </ul>\r\n *    <div class=\"control-input\">\r\n *       <input type=\"text\" #itemname />\r\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\r\n *    </div>\r\n *   `\r\n * })\r\n * export class MyComponent implements OnInit {\r\n *\r\n *   // services for data operations and data streaming\r\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\r\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\r\n *\r\n *   // observables for template\r\n *   items: Observable<Item[]>;\r\n *   profile: Observable<Profile>;\r\n *\r\n *   // inject main service\r\n *   constructor(private readonly afs: AngularFirestore) {}\r\n *\r\n *   ngOnInit() {\r\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\r\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\r\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\r\n *\r\n *     this.profileRef = afs.doc('users/davideast');\r\n *     this.profile = this.profileRef.valueChanges();\r\n *   }\r\n *\r\n *   addItem(name: string) {\r\n *     const user = 'davideast';\r\n *     this.itemsRef.add({ name, user });\r\n *   }\r\n * }\r\n */\r\nexport declare class AngularFirestore {\r\n    readonly firestore: firebase.firestore.Firestore;\r\n    readonly persistenceEnabled$: Observable<boolean>;\r\n    readonly schedulers: ɵAngularFireSchedulers;\r\n    readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\r\n    /**\r\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\r\n     * don't rely on the main Firebase App instance and we can create named\r\n     * apps and use multiple apps.\r\n     */\r\n    constructor(options: FirebaseOptions, nameOrConfig: string | FirebaseAppConfig | null | undefined, shouldEnablePersistence: boolean | null, settings: Settings | null, platformId: Object, zone: NgZone, persistenceSettings: PersistenceSettings | null, _useEmulator: any, useAuthEmulator: any);\r\n    /**\r\n     * Create a reference to a Firestore Collection based on a path or\r\n     * CollectionReference and an optional query function to narrow the result\r\n     * set.\r\n     */\r\n    collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\r\n    collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\r\n    /**\r\n     * Create a reference to a Firestore Collection Group based on a collectionId\r\n     * and an optional query function to narrow the result\r\n     * set.\r\n     */\r\n    collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn<T>): AngularFirestoreCollectionGroup<T>;\r\n    /**\r\n     * Create a reference to a Firestore Document based on a path or\r\n     * DocumentReference. Note that documents are not queryable because they are\r\n     * simply objects. However, documents have sub-collections that return a\r\n     * Collection reference and can be queried.\r\n     */\r\n    doc<T>(path: string): AngularFirestoreDocument<T>;\r\n    doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\r\n    /**\r\n     * Returns a generated Firestore Document Id.\r\n     */\r\n    createId(): string;\r\n}\r\nexport {};\r\n"]}