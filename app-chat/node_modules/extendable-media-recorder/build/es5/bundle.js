(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/regenerator'), require('media-encoder-host'), require('@babel/runtime/helpers/objectWithoutProperties'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('@babel/runtime/helpers/assertThisInitialized'), require('@babel/runtime/helpers/inherits'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/slicedToArray'), require('recorder-audio-worklet'), require('standardized-audio-context'), require('@babel/runtime/helpers/toConsumableArray'), require('multi-buffer-data-view'), require('subscribable-things')) :
    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/regenerator', 'media-encoder-host', '@babel/runtime/helpers/objectWithoutProperties', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', '@babel/runtime/helpers/assertThisInitialized', '@babel/runtime/helpers/inherits', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/slicedToArray', 'recorder-audio-worklet', 'standardized-audio-context', '@babel/runtime/helpers/toConsumableArray', 'multi-buffer-data-view', 'subscribable-things'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.extendableMediaRecorder = {}, global._asyncToGenerator, global._regeneratorRuntime, global.mediaEncoderHost, global._objectWithoutProperties, global._classCallCheck, global._createClass, global._assertThisInitialized, global._inherits, global._possibleConstructorReturn, global._getPrototypeOf, global._slicedToArray, global.recorderAudioWorklet, global.standardizedAudioContext, global._toConsumableArray, global.multiBufferDataView, global.subscribableThings));
}(this, (function (exports, _asyncToGenerator, _regeneratorRuntime, mediaEncoderHost, _objectWithoutProperties, _classCallCheck, _createClass, _assertThisInitialized, _inherits, _possibleConstructorReturn, _getPrototypeOf, _slicedToArray, recorderAudioWorklet, standardizedAudioContext, _toConsumableArray, multiBufferDataView, subscribableThings) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
    var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
    var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
    var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
    var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
    var _assertThisInitialized__default = /*#__PURE__*/_interopDefaultLegacy(_assertThisInitialized);
    var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
    var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
    var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
    var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
    var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);

    var _excluded = ["data"];
    var createBlobEventFactory = function createBlobEventFactory(nativeBlobEventConstructor) {
      return function (type, blobEventInit) {
        // Bug #14: Safari does not yet support the BlobEvent.
        if (nativeBlobEventConstructor === null) {
          var data = blobEventInit.data,
              eventInit = _objectWithoutProperties__default['default'](blobEventInit, _excluded);

          var fakeBlobEvent = new Event(type, eventInit);
          fakeBlobEvent.data = data;
          return fakeBlobEvent;
        }

        return new nativeBlobEventConstructor(type, blobEventInit);
      };
    };

    var createDecodeWebMChunk = function createDecodeWebMChunk(readElementContent, readElementType) {
      return function (dataView, elementType, channelCount) {
        var contents = [];
        var currentElementType = elementType;
        var offset = 0;

        while (offset < dataView.byteLength) {
          if (currentElementType === null) {
            var lengthAndType = readElementType(dataView, offset);

            if (lengthAndType === null) {
              break;
            }

            var length = lengthAndType.length,
                type = lengthAndType.type;
            currentElementType = type;
            offset += length;
          } else {
            var contentAndLength = readElementContent(dataView, offset, currentElementType, channelCount);

            if (contentAndLength === null) {
              break;
            }

            var content = contentAndLength.content,
                _length = contentAndLength.length;
            currentElementType = null;
            offset += _length;

            if (content !== null) {
              contents.push(content);
            }
          }
        }

        return {
          contents: contents,
          currentElementType: currentElementType,
          offset: offset
        };
      };
    };

    var createEventTargetConstructor = function createEventTargetConstructor(createEventTarget, wrapEventListener) {
      return /*#__PURE__*/function () {
        function EventTarget() {
          var nativeEventTarget = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          _classCallCheck__default['default'](this, EventTarget);

          this._listeners = new WeakMap();
          this._nativeEventTarget = nativeEventTarget === null ? createEventTarget() : nativeEventTarget;
        }

        _createClass__default['default'](EventTarget, [{
          key: "addEventListener",
          value: function addEventListener(type, listener, options) {
            if (listener !== null) {
              var wrappedEventListener = this._listeners.get(listener);

              if (wrappedEventListener === undefined) {
                wrappedEventListener = wrapEventListener(this, listener);

                if (typeof listener === 'function') {
                  this._listeners.set(listener, wrappedEventListener);
                }
              }

              this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
            }
          }
        }, {
          key: "dispatchEvent",
          value: function dispatchEvent(event) {
            return this._nativeEventTarget.dispatchEvent(event);
          }
        }, {
          key: "removeEventListener",
          value: function removeEventListener(type, listener, options) {
            var wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);

            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);
          }
        }]);

        return EventTarget;
      }();
    };

    var createEventTargetFactory = function createEventTargetFactory(window) {
      return function () {
        if (window === null) {
          throw new Error('A native EventTarget could not be created.');
        }

        return window.document.createElement('p');
      };
    };

    var createInvalidModificationError = function createInvalidModificationError() {
      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

      try {
        return new DOMException(message, 'InvalidModificationError');
      } catch (err) {
        // @todo Edge is the only browser that does not yet allow to construct a DOMException.
        err.code = 13;
        err.message = message;
        err.name = 'InvalidModificationError';
        return err;
      }
    };

    var createInvalidStateError = function createInvalidStateError() {
      try {
        return new DOMException('', 'InvalidStateError');
      } catch (err) {
        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.
        err.code = 11;
        err.name = 'InvalidStateError';
        return err;
      }
    };

    var createIsSupportedPromise = function createIsSupportedPromise(window) {
      if (window !== null && window.MediaStream !== undefined && (
      /*
       * Bug #10: An early experimental implemenation in Safari did not provide the isTypeSupported() function.
       */
      window.MediaRecorder === undefined || window.MediaRecorder.isTypeSupported !== undefined)) {
        /*
         * Bug #5: Up until v70 Firefox did emit a blob of type video/webm when asked to encode a MediaStream with a video track into an
         * audio codec.
         */
        return new Promise(function (resolve) {
          // Bug #11 Safari does not yet support the MediaRecorder but that isn't tested here.
          if (window.MediaRecorder === undefined) {
            return resolve(true);
          } // @todo captureStream() is not defined yet.


          var canvasElement = document.createElement('canvas'); // @todo https://bugzilla.mozilla.org/show_bug.cgi?id=1388974

          canvasElement.getContext('2d');

          if (typeof canvasElement.captureStream !== 'function') {
            return resolve(false);
          }

          var mediaStream = canvasElement.captureStream();
          var mimeType = 'audio/webm';

          try {
            var mediaRecorder = new window.MediaRecorder(mediaStream, {
              mimeType: mimeType
            });
            mediaRecorder.addEventListener('dataavailable', function (_ref) {
              var data = _ref.data;
              return resolve(data.type === mimeType);
            });
            mediaRecorder.start();
            setTimeout(function () {
              return mediaRecorder.stop();
            }, 10);
          } catch (err) {
            resolve(err.name === 'NotSupportedError');
          }
        });
      }

      return Promise.resolve(false);
    };

    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

    var createMediaRecorderConstructor = function createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) {
      return /*#__PURE__*/function (_eventTargetConstruct) {
        _inherits__default['default'](MediaRecorder, _eventTargetConstruct);

        var _super = _createSuper(MediaRecorder);

        function MediaRecorder(stream) {
          var _this;

          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          _classCallCheck__default['default'](this, MediaRecorder);

          var mimeType = options.mimeType;

          if (nativeMediaRecorderConstructor !== null && ( // Bug #10: Safari does not yet implement the isTypeSupported() method.
          mimeType === undefined || nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType))) {
            var internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);
            _this = _super.call(this, internalMediaRecorder);
            _this._internalMediaRecorder = internalMediaRecorder;
          } else if (mimeType !== undefined && encoderRegexes.some(function (regex) {
            return regex.test(mimeType);
          })) {
            _this = _super.call(this); // Bug #10: Safari does not yet implement the isTypeSupported() method.

            if (nativeMediaRecorderConstructor !== null && nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {
              _this._internalMediaRecorder = createWebmPcmMediaRecorder(_assertThisInitialized__default['default'](_this), nativeMediaRecorderConstructor, stream, mimeType);
            } else {
              _this._internalMediaRecorder = createWebAudioMediaRecorder(_assertThisInitialized__default['default'](_this), stream, mimeType);
            }
          } else {
            // This is creating a native MediaRecorder just to provoke it to throw an error.
            if (nativeMediaRecorderConstructor !== null) {
              createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);
            }

            throw createNotSupportedError();
          }

          _this._ondataavailable = null;
          _this._onerror = null;
          _this._onstop = null;
          return _possibleConstructorReturn__default['default'](_this);
        }

        _createClass__default['default'](MediaRecorder, [{
          key: "mimeType",
          get: function get() {
            return this._internalMediaRecorder.mimeType;
          }
        }, {
          key: "ondataavailable",
          get: function get() {
            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];
          },
          set: function set(value) {
            if (this._ondataavailable !== null) {
              this.removeEventListener('dataavailable', this._ondataavailable[1]);
            }

            if (typeof value === 'function') {
              var boundListener = value.bind(this);
              this.addEventListener('dataavailable', boundListener);
              this._ondataavailable = [value, boundListener];
            } else {
              this._ondataavailable = null;
            }
          }
        }, {
          key: "onerror",
          get: function get() {
            return this._onerror === null ? this._onerror : this._onerror[0];
          },
          set: function set(value) {
            if (this._onerror !== null) {
              this.removeEventListener('error', this._onerror[1]);
            }

            if (typeof value === 'function') {
              var boundListener = value.bind(this);
              this.addEventListener('error', boundListener);
              this._onerror = [value, boundListener];
            } else {
              this._onerror = null;
            }
          }
        }, {
          key: "onstop",
          get: function get() {
            return this._onstop === null ? this._onstop : this._onstop[0];
          },
          set: function set(value) {
            if (this._onstop !== null) {
              this.removeEventListener('stop', this._onstop[1]);
            }

            if (typeof value === 'function') {
              var boundListener = value.bind(this);
              this.addEventListener('stop', boundListener);
              this._onstop = [value, boundListener];
            } else {
              this._onstop = null;
            }
          }
        }, {
          key: "state",
          get: function get() {
            return this._internalMediaRecorder.state;
          }
        }, {
          key: "start",
          value: function start(timeslice) {
            return this._internalMediaRecorder.start(timeslice);
          }
        }, {
          key: "stop",
          value: function stop() {
            return this._internalMediaRecorder.stop();
          }
        }], [{
          key: "isTypeSupported",
          value: function isTypeSupported(mimeType) {
            return nativeMediaRecorderConstructor !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.
            nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType) || encoderRegexes.some(function (regex) {
              return regex.test(mimeType);
            });
          }
        }]);

        return MediaRecorder;
      }(eventTargetConstructor);
    };

    var createNativeBlobEventConstructor = function createNativeBlobEventConstructor(window) {
      if (window !== null && window.BlobEvent !== undefined) {
        return window.BlobEvent;
      }

      return null;
    };

    var createNativeMediaRecorderFactory = function createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError) {
      return function (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) {
        var dataAvailableListeners = new WeakMap();
        var errorListeners = new WeakMap();
        var nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);

        nativeMediaRecorder.addEventListener = function (addEventListener) {
          return function (type, listener, options) {
            var patchedEventListener = listener;

            if (typeof listener === 'function') {
              if (type === 'dataavailable' || type === 'stop') {
                // Bug #7 & 8: Chrome fires the dataavailable and stop events before it fires the error event.
                patchedEventListener = function patchedEventListener(event) {
                  return setTimeout(function () {
                    return listener.call(nativeMediaRecorder, event);
                  });
                };

                dataAvailableListeners.set(listener, patchedEventListener);
              } else if (type === 'error') {
                patchedEventListener = function patchedEventListener(event) {
                  // Bug #3 & 4: Chrome throws an error event without any error.
                  if (event.error === undefined) {
                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {
                      error: createInvalidModificationError()
                    })); // Bug #1 & 2: Firefox throws an error event with an UnknownError.
                  } else if (event.error.name === 'UnknownError') {
                    var message = event.error.message;
                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {
                      error: createInvalidModificationError(message)
                    }));
                  } else if (!(event instanceof ErrorEvent)) {
                    listener.call(nativeMediaRecorder, new ErrorEvent('error', {
                      error: event.error
                    }));
                  } else {
                    listener.call(nativeMediaRecorder, event);
                  }
                };

                dataAvailableListeners.set(listener, patchedEventListener);
              }
            }

            return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);
          };
        }(nativeMediaRecorder.addEventListener);

        nativeMediaRecorder.removeEventListener = function (removeEventListener) {
          return function (type, listener, options) {
            var patchedEventListener = listener;

            if (typeof listener === 'function') {
              if (type === 'dataavailable') {
                var dataAvailableListener = dataAvailableListeners.get(listener);

                if (dataAvailableListener !== undefined) {
                  patchedEventListener = dataAvailableListener;
                }
              } else if (type === 'error') {
                var errorListener = errorListeners.get(listener);

                if (errorListener !== undefined) {
                  patchedEventListener = errorListener;
                }
              }
            }

            return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);
          };
        }(nativeMediaRecorder.removeEventListener);

        nativeMediaRecorder.start = function (start) {
          return function (timeslice) {
            /*
             * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio
             * codec.
             */
            if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {
              throw createNotSupportedError();
            }

            return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);
          };
        }(nativeMediaRecorder.start);

        return nativeMediaRecorder;
      };
    };

    var createNativeMediaRecorderConstructor = function createNativeMediaRecorderConstructor(window) {
      if (window === null) {
        return null;
      }

      return window.MediaRecorder === undefined ? null : window.MediaRecorder;
    };

    var createNotSupportedError = function createNotSupportedError() {
      try {
        return new DOMException('', 'NotSupportedError');
      } catch (err) {
        // @todo Edge is the only browser that does not yet allow to construct a DOMException.
        err.code = 9;
        err.name = 'NotSupportedError';
        return err;
      }
    };

    var createReadElementContent = function createReadElementContent(readVariableSizeInteger) {
      return function (dataView, offset, type) {
        var channelCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
        var lengthAndValue = readVariableSizeInteger(dataView, offset);

        if (lengthAndValue === null) {
          return lengthAndValue;
        }

        var length = lengthAndValue.length,
            value = lengthAndValue.value;

        if (type === 'master') {
          return {
            content: null,
            length: length
          };
        }

        if (offset + length + value > dataView.byteLength) {
          return null;
        }

        if (type === 'binary') {
          var numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;
          var content = Array.from({
            length: channelCount
          }, function () {
            return new Float32Array(numberOfSamples);
          });

          for (var i = 0; i < numberOfSamples; i += 1) {
            var elementOffset = i * channelCount + 1;

            for (var j = 0; j < channelCount; j += 1) {
              content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);
            }
          }

          return {
            content: content,
            length: length + value
          };
        }

        return {
          content: null,
          length: length + value
        };
      };
    };

    var createReadElementType = function createReadElementType(readVariableSizeInteger) {
      return function (dataView, offset) {
        var lengthAndValue = readVariableSizeInteger(dataView, offset);

        if (lengthAndValue === null) {
          return lengthAndValue;
        }

        var length = lengthAndValue.length,
            value = lengthAndValue.value;

        if (value === 35) {
          return {
            length: length,
            type: 'binary'
          };
        }

        if (value === 46 || value === 97 || value === 88713574 || value === 106212971 || value === 139690087 || value === 172351395 || value === 256095861) {
          return {
            length: length,
            type: 'master'
          };
        }

        return {
          length: length,
          type: 'unknown'
        };
      };
    };

    var createReadVariableSizeInteger = function createReadVariableSizeInteger(readVariableSizeIntegerLength) {
      return function (dataView, offset) {
        var length = readVariableSizeIntegerLength(dataView, offset);

        if (length === null) {
          return length;
        }

        var firstDataByteOffset = offset + Math.floor((length - 1) / 8);

        if (firstDataByteOffset + length > dataView.byteLength) {
          return null;
        }

        var firstDataByte = dataView.getUint8(firstDataByteOffset);
        var value = firstDataByte & (1 << 8 - length % 8) - 1; // tslint:disable-line:no-bitwise

        for (var i = 1; i < length; i += 1) {
          value = (value << 8) + dataView.getUint8(firstDataByteOffset + i); // tslint:disable-line:no-bitwise
        }

        return {
          length: length,
          value: value
        };
      };
    };

    var ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.

    var createPromisedAudioNodesEncoderIdAndPort = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(audioBuffer, audioContext, channelCount, mediaStream, mimeType) {
        var _yield$instantiate, encoderId, port, audioBufferSourceNode, mediaStreamAudioSourceNode, recorderAudioWorkletNode;

        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return mediaEncoderHost.instantiate(mimeType, audioContext.sampleRate);

              case 2:
                _yield$instantiate = _context.sent;
                encoderId = _yield$instantiate.encoderId;
                port = _yield$instantiate.port;

                if (!(standardizedAudioContext.AudioWorkletNode === undefined)) {
                  _context.next = 7;
                  break;
                }

                throw new Error(ERROR_MESSAGE);

              case 7:
                audioBufferSourceNode = new standardizedAudioContext.AudioBufferSourceNode(audioContext, {
                  buffer: audioBuffer
                });
                mediaStreamAudioSourceNode = new standardizedAudioContext.MediaStreamAudioSourceNode(audioContext, {
                  mediaStream: mediaStream
                });
                recorderAudioWorkletNode = recorderAudioWorklet.createRecorderAudioWorkletNode(standardizedAudioContext.AudioWorkletNode, audioContext, {
                  channelCount: channelCount
                });
                return _context.abrupt("return", {
                  audioBufferSourceNode: audioBufferSourceNode,
                  encoderId: encoderId,
                  mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,
                  port: port,
                  recorderAudioWorkletNode: recorderAudioWorkletNode
                });

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function createPromisedAudioNodesEncoderIdAndPort(_x, _x2, _x3, _x4, _x5) {
        return _ref.apply(this, arguments);
      };
    }();

    var createWebAudioMediaRecorderFactory = function createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) {
      return function (eventTarget, mediaStream, mimeType) {
        var audioContext = new standardizedAudioContext.MinimalAudioContext({
          latencyHint: 'playback'
        });
        var length = Math.max(512, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));
        var audioBuffer = new standardizedAudioContext.AudioBuffer({
          length: length,
          sampleRate: audioContext.sampleRate
        });
        var promisedAudioWorkletModule = recorderAudioWorklet.addRecorderAudioWorkletModule(function (url) {
          if (standardizedAudioContext.addAudioWorkletModule === undefined) {
            throw new Error(ERROR_MESSAGE);
          }

          return standardizedAudioContext.addAudioWorkletModule(audioContext, url);
        });
        var abortRecording = null;
        var intervalId = null;
        var promisedAudioNodesAndEncoderId = null;
        var promisedPartialRecording = null;

        var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {
          eventTarget.dispatchEvent(createBlobEvent('dataavailable', {
            data: new Blob(arrayBuffers, {
              type: mimeType
            })
          }));
        };

        var requestNextPartialRecording = /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(encoderId, timeslice) {
            return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.t0 = dispatchDataAvailableEvent;
                    _context2.next = 3;
                    return mediaEncoderHost.encode(encoderId, timeslice);

                  case 3:
                    _context2.t1 = _context2.sent;
                    (0, _context2.t0)(_context2.t1);

                    if (promisedAudioNodesAndEncoderId !== null) {
                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
                    }

                  case 6:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          return function requestNextPartialRecording(_x6, _x7) {
            return _ref2.apply(this, arguments);
          };
        }();

        var stop = function stop() {
          if (promisedAudioNodesAndEncoderId === null) {
            return;
          }

          if (abortRecording !== null) {
            mediaStream.removeEventListener('addtrack', abortRecording);
            mediaStream.removeEventListener('removetrack', abortRecording);
          }

          if (intervalId !== null) {
            clearTimeout(intervalId);
          }

          if (promisedPartialRecording !== null) {
            promisedPartialRecording["catch"](function () {
              /* @todo Only catch the errors caused by a duplicate call to encode. */
            });
            promisedPartialRecording = null;
          }

          promisedAudioNodesAndEncoderId.then( /*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee3(_ref3) {
              var encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode;
              return _regeneratorRuntime__default['default'].wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      encoderId = _ref3.encoderId, mediaStreamAudioSourceNode = _ref3.mediaStreamAudioSourceNode, recorderAudioWorkletNode = _ref3.recorderAudioWorkletNode;
                      _context3.next = 3;
                      return recorderAudioWorkletNode.stop();

                    case 3:
                      mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);
                      _context3.t0 = dispatchDataAvailableEvent;
                      _context3.next = 7;
                      return mediaEncoderHost.encode(encoderId, null);

                    case 7:
                      _context3.t1 = _context3.sent;
                      (0, _context3.t0)(_context3.t1);
                      eventTarget.dispatchEvent(new Event('stop'));

                    case 10:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));

            return function (_x8) {
              return _ref4.apply(this, arguments);
            };
          }());
          promisedAudioNodesAndEncoderId = null;
        };

        return {
          get mimeType() {
            return mimeType;
          },

          get state() {
            return promisedAudioNodesAndEncoderId === null ? 'inactive' : 'recording';
          },

          start: function start(timeslice) {
            var _a;

            if (promisedAudioNodesAndEncoderId !== null) {
              throw createInvalidStateError();
            }

            if (mediaStream.getVideoTracks().length > 0) {
              throw createNotSupportedError();
            }

            var audioTracks = mediaStream.getAudioTracks();
            var channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;
            promisedAudioNodesAndEncoderId = Promise.all([audioContext.resume(), promisedAudioWorkletModule.then(function () {
              return createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType);
            })]).then( /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee4(_ref5) {
                var _ref7, _ref7$, audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode;

                return _regeneratorRuntime__default['default'].wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _ref7 = _slicedToArray__default['default'](_ref5, 2), _ref7$ = _ref7[1], audioBufferSourceNode = _ref7$.audioBufferSourceNode, encoderId = _ref7$.encoderId, mediaStreamAudioSourceNode = _ref7$.mediaStreamAudioSourceNode, port = _ref7$.port, recorderAudioWorkletNode = _ref7$.recorderAudioWorkletNode;
                        mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);
                        _context4.next = 4;
                        return new Promise(function (resolve) {
                          audioBufferSourceNode.onended = resolve;
                          audioBufferSourceNode.connect(recorderAudioWorkletNode);
                          audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);
                        });

                      case 4:
                        audioBufferSourceNode.disconnect(recorderAudioWorkletNode);
                        _context4.next = 7;
                        return recorderAudioWorkletNode.record(port);

                      case 7:
                        if (timeslice !== undefined) {
                          promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
                        }

                        return _context4.abrupt("return", {
                          encoderId: encoderId,
                          mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,
                          recorderAudioWorkletNode: recorderAudioWorkletNode
                        });

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x9) {
                return _ref6.apply(this, arguments);
              };
            }());
            var tracks = mediaStream.getTracks();

            abortRecording = function abortRecording() {
              stop();
              eventTarget.dispatchEvent(new ErrorEvent('error', {
                error: createInvalidModificationError()
              }));
            };

            mediaStream.addEventListener('addtrack', abortRecording);
            mediaStream.addEventListener('removetrack', abortRecording);
            intervalId = setInterval(function () {
              var currentTracks = mediaStream.getTracks();

              if ((currentTracks.length !== tracks.length || currentTracks.some(function (track, index) {
                return track !== tracks[index];
              })) && abortRecording !== null) {
                abortRecording();
              }
            }, 1000);
          },
          stop: stop
        };
      };
    };

    var createWebmPcmMediaRecorderFactory = function createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk) {
      return function (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) {
        var nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {
          mimeType: 'audio/webm;codecs=pcm'
        });
        var audioTracks = mediaStream.getAudioTracks();
        var channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;
        var sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;
        var promisedPartialRecording = null;

        var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {
          eventTarget.dispatchEvent(createBlobEvent('dataavailable', {
            data: new Blob(arrayBuffers, {
              type: mimeType
            })
          }));
        };

        var requestNextPartialRecording = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(encoderId, timeslice) {
            return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.t0 = dispatchDataAvailableEvent;
                    _context.next = 3;
                    return mediaEncoderHost.encode(encoderId, timeslice);

                  case 3:
                    _context.t1 = _context.sent;
                    (0, _context.t0)(_context.t1);

                    if (nativeMediaRecorder.state !== 'inactive') {
                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
                    }

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function requestNextPartialRecording(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();

        var stop = function stop() {
          if (nativeMediaRecorder.state === 'inactive') {
            return;
          }

          if (promisedPartialRecording !== null) {
            promisedPartialRecording["catch"](function () {
              /* @todo Only catch the errors caused by a duplicate call to encode. */
            });
            promisedPartialRecording = null;
          }

          nativeMediaRecorder.stop();
        };

        nativeMediaRecorder.addEventListener('error', function () {
          stop(); // Bug #3 & 4: Chrome throws an error event without any error.

          eventTarget.dispatchEvent(new ErrorEvent('error', {
            error: createInvalidModificationError()
          }));
        });
        return {
          get mimeType() {
            return mimeType;
          },

          get state() {
            return nativeMediaRecorder.state;
          },

          start: function start(timeslice) {
            /*
             * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio
             * codec.
             */
            if (mediaStream.getVideoTracks().length > 0) {
              throw createNotSupportedError();
            }

            if (nativeMediaRecorder.state === 'inactive') {
              var promisedDataViewElementTypeEncoderIdAndPort = null;

              if (sampleRate !== undefined) {
                promisedDataViewElementTypeEncoderIdAndPort = mediaEncoderHost.instantiate(mimeType, sampleRate);
              } // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.


              var pendingInvocations = 0;
              var removeEventListener = subscribableThings.on(nativeMediaRecorder, 'dataavailable')(function (_ref2) {
                var data = _ref2.data;
                pendingInvocations += 1;

                if (promisedDataViewElementTypeEncoderIdAndPort !== null) {
                  promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee2(_ref3) {
                      var _ref3$dataView, dataView, _ref3$elementType, elementType, encoderId, port, multiOrSingleBufferDataView, _decodeWebMChunk, currentElementType, offset, contents, buffers, remainingDataView;

                      return _regeneratorRuntime__default['default'].wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _ref3$dataView = _ref3.dataView, dataView = _ref3$dataView === void 0 ? null : _ref3$dataView, _ref3$elementType = _ref3.elementType, elementType = _ref3$elementType === void 0 ? null : _ref3$elementType, encoderId = _ref3.encoderId, port = _ref3.port;

                              if (!(dataView === null)) {
                                _context2.next = 9;
                                break;
                              }

                              _context2.t1 = DataView;
                              _context2.next = 5;
                              return data.arrayBuffer();

                            case 5:
                              _context2.t2 = _context2.sent;
                              _context2.t0 = new _context2.t1(_context2.t2);
                              _context2.next = 19;
                              break;

                            case 9:
                              _context2.t3 = multiBufferDataView.MultiBufferDataView;
                              _context2.t4 = [];
                              _context2.t5 = _toConsumableArray__default['default'](dataView.buffers);
                              _context2.next = 14;
                              return data.arrayBuffer();

                            case 14:
                              _context2.t6 = _context2.sent;
                              _context2.t7 = [_context2.t6];
                              _context2.t8 = _context2.t4.concat.call(_context2.t4, _context2.t5, _context2.t7);
                              _context2.t9 = dataView.byteOffset;
                              _context2.t0 = new _context2.t3(_context2.t8, _context2.t9);

                            case 19:
                              multiOrSingleBufferDataView = _context2.t0;
                              _decodeWebMChunk = decodeWebMChunk(multiOrSingleBufferDataView, elementType, channelCount), currentElementType = _decodeWebMChunk.currentElementType, offset = _decodeWebMChunk.offset, contents = _decodeWebMChunk.contents;
                              buffers = 'buffer' in multiOrSingleBufferDataView ? [multiOrSingleBufferDataView.buffer] : multiOrSingleBufferDataView.buffers;
                              remainingDataView = offset < multiOrSingleBufferDataView.byteLength ? new multiBufferDataView.MultiBufferDataView(buffers, multiOrSingleBufferDataView.byteOffset + offset) : null;
                              contents.forEach(function (content) {
                                return port.postMessage(content, content.map(function (_ref5) {
                                  var buffer = _ref5.buffer;
                                  return buffer;
                                }));
                              });
                              pendingInvocations -= 1;

                              if (pendingInvocations === 0 && nativeMediaRecorder.state === 'inactive') {
                                mediaEncoderHost.encode(encoderId, null).then(function (arrayBuffers) {
                                  dispatchDataAvailableEvent(arrayBuffers);
                                  eventTarget.dispatchEvent(new Event('stop'));
                                });
                                port.postMessage([]);
                                port.close();
                                removeEventListener();
                              }

                              return _context2.abrupt("return", {
                                dataView: remainingDataView,
                                elementType: currentElementType,
                                encoderId: encoderId,
                                port: port
                              });

                            case 27:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));

                    return function (_x3) {
                      return _ref4.apply(this, arguments);
                    };
                  }());
                }
              });

              if (promisedDataViewElementTypeEncoderIdAndPort !== null && timeslice !== undefined) {
                promisedDataViewElementTypeEncoderIdAndPort.then(function (_ref6) {
                  var encoderId = _ref6.encoderId;
                  return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
                });
              }
            }

            nativeMediaRecorder.start(100);
          },
          stop: stop
        };
      };
    };

    var createWindow = function createWindow() {
      return typeof window === 'undefined' ? null : window;
    };

    var readVariableSizeIntegerLength = function readVariableSizeIntegerLength(dataView, offset) {
      if (offset >= dataView.byteLength) {
        return null;
      }

      var _byte = dataView.getUint8(offset);

      if (_byte > 127) {
        return 1;
      }

      if (_byte > 63) {
        return 2;
      }

      if (_byte > 31) {
        return 3;
      }

      if (_byte > 15) {
        return 4;
      }

      if (_byte > 7) {
        return 5;
      }

      if (_byte > 3) {
        return 6;
      }

      if (_byte > 1) {
        return 7;
      }

      if (_byte > 0) {
        return 8;
      }

      var length = readVariableSizeIntegerLength(dataView, offset + 1);
      return length === null ? null : length + 8;
    };

    var wrapEventListener = function wrapEventListener(target, eventListener) {
      return function (event) {
        var descriptor = {
          value: target
        };
        Object.defineProperties(event, {
          currentTarget: descriptor,
          target: descriptor
        });

        if (typeof eventListener === 'function') {
          return eventListener.call(target, event);
        }

        return eventListener.handleEvent.call(target, event);
      };
    };

    var encoderRegexes = [];
    var window$1 = createWindow();
    var nativeBlobEventConstructor = createNativeBlobEventConstructor(window$1);
    var createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);
    var createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError);
    var readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);
    var readElementContent = createReadElementContent(readVariableSizeInteger);
    var readElementType = createReadElementType(readVariableSizeInteger);
    var decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);
    var createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk);
    var createEventTarget = createEventTargetFactory(window$1);
    var nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window$1);
    var createNativeMediaRecorder = createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError);
    var mediaRecorderConstructor = createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, createEventTargetConstructor(createEventTarget, wrapEventListener), nativeMediaRecorderConstructor);
    var isSupported = function isSupported() {
      return createIsSupportedPromise(window$1);
    };
    var register = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator__default['default']( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function _callee(port) {
        return _regeneratorRuntime__default['default'].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = encoderRegexes;
                _context.next = 3;
                return mediaEncoderHost.register(port);

              case 3:
                _context.t1 = _context.sent;

                _context.t0.push.call(_context.t0, _context.t1);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function register(_x) {
        return _ref.apply(this, arguments);
      };
    }();

    exports.MediaRecorder = mediaRecorderConstructor;
    exports.isSupported = isSupported;
    exports.register = register;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
